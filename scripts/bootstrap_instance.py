#!/usr/bin/env python3
"""Bootstrap backend env + desktop client settings for a new installation."""

from __future__ import annotations

import argparse
import getpass
import json
import secrets
from pathlib import Path


ROOT_DIR = Path(__file__).resolve().parent.parent
BACKEND_DIR = ROOT_DIR / "backend"
APP_SETTINGS_PATH = ROOT_DIR / "app_settings.json"
ENV_FILE_BY_ENV = {
    "dev": BACKEND_DIR / ".env.dev",
    "prod": BACKEND_DIR / ".env.prod",
    "cloud": BACKEND_DIR / ".env.cloud",
}
SSL_MODES = {"disable", "allow", "prefer", "require", "verify-ca", "verify-full"}


def _prompt_text(label: str, default: str | None = None, required: bool = False) -> str:
    while True:
        suffix = f" [{default}]" if default else ""
        raw = input(f"{label}{suffix}: ").strip()
        value = raw if raw else (default or "")
        if required and not value:
            print("Value is required.")
            continue
        return value


def _prompt_bool(label: str, default: bool) -> bool:
    default_text = "Y/n" if default else "y/N"
    while True:
        raw = input(f"{label} ({default_text}): ").strip().lower()
        if not raw:
            return default
        if raw in {"y", "yes", "1", "true", "on"}:
            return True
        if raw in {"n", "no", "0", "false", "off"}:
            return False
        print("Enter yes or no.")


def _prompt_secret(label: str, default: str | None = None, required: bool = False) -> str:
    while True:
        suffix = " [hidden default available]" if default else ""
        raw = getpass.getpass(f"{label}{suffix}: ").strip()
        value = raw if raw else (default or "")
        if required and not value:
            print("Value is required.")
            continue
        return value


def _load_app_settings(path: Path) -> dict:
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8-sig") as handle:
            data = json.load(handle)
            return data if isinstance(data, dict) else {}
    except Exception:
        return {}


def _save_json(path: Path, payload: dict) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as handle:
        json.dump(payload, handle, indent=2, ensure_ascii=False)
        handle.write("\n")


def _validate_sslmode(value: str) -> str:
    candidate = value.strip().lower()
    if candidate not in SSL_MODES:
        raise ValueError(f"Invalid sslmode '{value}'. Use one of: {', '.join(sorted(SSL_MODES))}.")
    return candidate


def _env_line(key: str, value: str) -> str:
    escaped = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'{key}="{escaped}"'


def _build_env_payload(config: dict[str, str]) -> str:
    ordered_keys = [
        "APP_ENV",
        "DB_HOST",
        "DB_PORT",
        "DB_NAME",
        "DB_USER",
        "DB_PASSWORD",
        "DB_SSLMODE",
        "API_HOST",
        "API_PORT",
        "API_ADMIN_USER",
        "API_ADMIN_PASSWORD",
        "API_JWT_SECRET",
        "API_TOKEN_MINUTES",
        "API_LOGIN_RATE_LIMIT_ATTEMPTS",
        "API_LOGIN_RATE_LIMIT_WINDOW_SECONDS",
        "API_LOGIN_BLOCK_SECONDS",
    ]
    lines = [
        "# Generated by scripts/bootstrap_instance.py",
        "# Review values before deploying to production.",
        "",
    ]
    lines.extend(_env_line(key, config[key]) for key in ordered_keys)
    lines.append("")
    return "\n".join(lines)


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Configure backend (.env.<env>) and client (app_settings.json) for a new installation.",
    )
    parser.add_argument("--env", choices=["dev", "prod", "cloud"], default="dev")
    parser.add_argument("--non-interactive", action="store_true")

    parser.add_argument("--db-host")
    parser.add_argument("--db-port", type=int)
    parser.add_argument("--db-name")
    parser.add_argument("--db-user")
    parser.add_argument("--db-password")
    parser.add_argument("--db-sslmode")

    parser.add_argument("--api-base-url")
    parser.add_argument("--api-user")
    parser.add_argument("--api-password")
    parser.add_argument("--api-verify-tls", choices=["true", "false"])
    parser.add_argument("--api-ca-file", default="")

    parser.add_argument("--api-host", default="127.0.0.1")
    parser.add_argument("--api-port", type=int, default=8000)
    parser.add_argument("--api-admin-user", default="admin")
    parser.add_argument("--api-admin-password")
    parser.add_argument("--api-jwt-secret")
    parser.add_argument("--api-token-minutes", type=int, default=60)
    parser.add_argument("--api-login-rate-limit-attempts", type=int, default=5)
    parser.add_argument("--api-login-rate-limit-window-seconds", type=int, default=300)
    parser.add_argument("--api-login-block-seconds", type=int, default=900)
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    env_file = ENV_FILE_BY_ENV[args.env]
    existing_settings = _load_app_settings(APP_SETTINGS_PATH)
    existing_db = existing_settings.get("db", {}) if isinstance(existing_settings.get("db"), dict) else {}
    existing_api = existing_settings.get("api", {}) if isinstance(existing_settings.get("api"), dict) else {}

    interactive = not args.non_interactive
    if interactive:
        print(f"Bootstrapping environment '{args.env}'")
        print(f"Backend env file: {env_file}")
        print(f"Client settings : {APP_SETTINGS_PATH}")
        print("")

    db_host = args.db_host or str(existing_db.get("host", "localhost"))
    db_port = args.db_port or int(existing_db.get("port", 5432))
    db_name = args.db_name or str(existing_db.get("name", "cloudvienna"))
    db_user = args.db_user or ""
    db_password = args.db_password or ""
    db_sslmode = args.db_sslmode or str(existing_db.get("sslmode", "prefer"))

    api_base_url = args.api_base_url or str(existing_api.get("base_url", f"http://{args.api_host}:{args.api_port}"))
    api_user = args.api_user or str(existing_api.get("username", args.api_admin_user))
    api_password = args.api_password or str(existing_api.get("password", ""))
    if args.api_verify_tls is None:
        api_verify_tls = bool(existing_api.get("verify_tls", args.env != "dev"))
    else:
        api_verify_tls = args.api_verify_tls == "true"
    api_ca_file = str(args.api_ca_file or existing_api.get("ca_file", "")).strip()

    api_admin_password = args.api_admin_password or ""
    api_jwt_secret = args.api_jwt_secret or ""

    if interactive:
        db_host = _prompt_text("DB host", db_host, required=True)
        db_port = int(_prompt_text("DB port", str(db_port), required=True))
        db_name = _prompt_text("DB name", db_name, required=True)
        db_user = _prompt_text("DB user", db_user, required=True)
        db_password = _prompt_secret("DB password", default=db_password, required=True)
        db_sslmode = _validate_sslmode(_prompt_text("DB sslmode", db_sslmode, required=True))

        api_base_url = _prompt_text("Client API base_url", api_base_url, required=True).rstrip("/")
        api_user = _prompt_text("Client API username", api_user, required=True)
        api_password = _prompt_secret("Client API password", default=api_password, required=True)
        api_verify_tls = _prompt_bool("Client verify TLS", api_verify_tls)
        api_ca_file = _prompt_text("Client CA file (optional)", api_ca_file)

        api_admin_password = _prompt_secret("Backend API_ADMIN_PASSWORD", required=True)
        generated_secret = secrets.token_urlsafe(48)
        api_jwt_secret = _prompt_secret("Backend API_JWT_SECRET", default=generated_secret, required=True)
    else:
        if not db_user or not db_password:
            raise RuntimeError("Missing DB_USER/DB_PASSWORD. Provide --db-user and --db-password.")
        if not api_password:
            raise RuntimeError("Missing client API password. Provide --api-password.")
        if not api_admin_password:
            raise RuntimeError("Missing --api-admin-password in non-interactive mode.")
        if not api_jwt_secret:
            api_jwt_secret = secrets.token_urlsafe(48)

    db_sslmode = _validate_sslmode(db_sslmode)
    if args.env in {"prod", "cloud"}:
        if len(api_jwt_secret.strip()) < 32:
            raise RuntimeError("API_JWT_SECRET must have at least 32 characters in prod/cloud.")
        if api_admin_password.strip() in {"", "change-me"} or len(api_admin_password.strip()) < 12:
            raise RuntimeError("API_ADMIN_PASSWORD must be non-default and at least 12 characters in prod/cloud.")

    env_payload = {
        "APP_ENV": args.env,
        "DB_HOST": db_host.strip(),
        "DB_PORT": str(db_port),
        "DB_NAME": db_name.strip(),
        "DB_USER": db_user.strip(),
        "DB_PASSWORD": db_password,
        "DB_SSLMODE": db_sslmode,
        "API_HOST": str(args.api_host).strip(),
        "API_PORT": str(args.api_port),
        "API_ADMIN_USER": str(args.api_admin_user).strip(),
        "API_ADMIN_PASSWORD": api_admin_password,
        "API_JWT_SECRET": api_jwt_secret,
        "API_TOKEN_MINUTES": str(args.api_token_minutes),
        "API_LOGIN_RATE_LIMIT_ATTEMPTS": str(args.api_login_rate_limit_attempts),
        "API_LOGIN_RATE_LIMIT_WINDOW_SECONDS": str(args.api_login_rate_limit_window_seconds),
        "API_LOGIN_BLOCK_SECONDS": str(args.api_login_block_seconds),
    }

    env_file.write_text(_build_env_payload(env_payload), encoding="utf-8")

    merged_settings = dict(existing_settings)
    merged_settings["db"] = {
        **existing_db,
        "host": db_host.strip(),
        "port": int(db_port),
        "name": db_name.strip(),
        "sslmode": db_sslmode,
    }
    merged_settings["api"] = {
        **existing_api,
        "base_url": api_base_url,
        "username": api_user.strip(),
        "password": api_password,
        "verify_tls": bool(api_verify_tls),
        "ca_file": api_ca_file,
    }
    _save_json(APP_SETTINGS_PATH, merged_settings)

    print("Bootstrap complete.")
    print(f"- Backend env file updated: {env_file}")
    print(f"- Client settings updated : {APP_SETTINGS_PATH}")
    print("Use this environment when running the app/API:")
    print(f"  APP_ENV={args.env}")


if __name__ == "__main__":
    main()
